/*
 * generated by Xtext 2.12.0
 */
package eu.quanticol.jsstl.dsl.generator

import com.google.inject.Inject
import eu.quanticol.jsstl.dsl.jSSTLScript.AndFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.AtomicFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.ConstDeclaration
import eu.quanticol.jsstl.dsl.jSSTLScript.DiffExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.DisEqualRelationExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.DivExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.EqualRelationExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.EventuallyFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.EverywhereFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.Expression
import eu.quanticol.jsstl.dsl.jSSTLScript.FalseFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.FloatExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.FormulaDeclaration
import eu.quanticol.jsstl.dsl.jSSTLScript.GloballyFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.GreaterOrEqualRelationExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.GreaterRelationExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.IntExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.Interval
import eu.quanticol.jsstl.dsl.jSSTLScript.LessOrEqualRelationExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.LessRelationExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.LiteralExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.Model
import eu.quanticol.jsstl.dsl.jSSTLScript.MulExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.NotExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.NotFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.OrFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.ParameterDeclaration
import eu.quanticol.jsstl.dsl.jSSTLScript.ReferencedFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.RelationExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.SomewhereFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.SumExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.SurroundFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.TrueFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.UnaryMinusExpression
import eu.quanticol.jsstl.dsl.jSSTLScript.UntilFormula
import eu.quanticol.jsstl.dsl.jSSTLScript.VariableDeclarations
import eu.quanticol.jsstl.dsl.util.Utilities
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class JSSTLScriptGenerator extends AbstractGenerator {

	@Inject extension Utilities


	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var packageName = resource.URI.packageName
		var className = resource.URI.className
		var m = resource.allContents.toIterable.filter(typeof(Model)).head
		if (m != null) {
			fsa.generateFile(packageName+'/'+className+".java" , 
				m.generateJavaCode( packageName.replace('/','.') , className )
			)			
		}		
	}
	
	public final static String CONST_POSTFIX = "_CONST_";
	public final static String VAR_POSTFIX = "_VAR_";
	public final static String PAR_POSTFIX = "_PAR_";
	
	def generateJavaCode( Model model , String packageName , String className ) {
		'''
		package «packageName»;
		
		import eu.quanticol.jsstl.formula.*;
		import java.util.Map;		
		
		public class «className» extends jSSTLScript {
			
			«FOR e:model.elements.filter(typeof(ConstDeclaration))»
			public static final double «e.name+CONST_POSTFIX» = «e.value.generateExpressionCode»;
			«ENDFOR»
			
			«FOR v:model.elements.filter(typeof(VariableDeclarations)).generateVariableIndexes»
			public static final int «v.key.name+VAR_POSTFIX» = «v.value»;
			«ENDFOR»
			
			public «className»() {
				super( 
					new String[] {
						«FOR f:model.elements.filter(typeof(VariableDeclarations)) SEPARATOR ','»
						"«f.name»"
						«ENDFOR»
					}
				);	
				«FOR f:model.elements.filter(typeof(FormulaDeclaration))»
				addFormula( "«f.name»" ,
					«f.body.generateFormulaCode» ,
					null );
				«ENDFOR»
				«FOR p:model.elements.filter(typeof(ParameterDeclaration))»
				addParameter( "«p.name»" , 
					(double) «p.range.min.generateExpressionCode» , 
					(double) «p.range.max.generateExpressionCode» );
				«ENDFOR»
			}

		}
		'''
	}
	
	def generateVariableIndexes( Iterable<VariableDeclarations> variables ) {
		var counter = 0;
		var toReturn = newLinkedList()
		for (v : variables) {
			toReturn.add(new Pair(v,counter))
			counter = counter+1
		}
		toReturn
	}
	
	def dispatch CharSequence generateExpressionCode( IntExpression e ) {
		'''«e.value»'''
	}
	
	def dispatch CharSequence generateExpressionCode( FloatExpression e ) {
		'''«e.intPart».«e.decPart»'''
	}
	
	def dispatch CharSequence generateExpressionCode( TrueFormula e ) {
		'''true'''
	}
	
	def dispatch CharSequence generateExpressionCode( FalseFormula e ) {
		'''false'''
	}
	
	def dispatch CharSequence generateExpressionCode( NotExpression e ) {
		'''!( «e.arg.generateExpressionCode» )'''
	}
	
	def dispatch CharSequence generateExpressionCode( UnaryMinusExpression e ) {
		'''-( «e.arg.generateExpressionCode» )'''
	}
	
	def dispatch CharSequence generateExpressionCode( LiteralExpression e ) {
		val v = e.reference
		switch v {
			VariableDeclarations: '''variables[getIndex(«v.name+VAR_POSTFIX»)]'''
			ConstDeclaration: v.name+CONST_POSTFIX
			ParameterDeclaration: '''parameters.get("«v.name»")'''
		}	
	}
	
	def dispatch CharSequence generateExpressionCode( MulExpression e ) {
		'''( «e.left.generateExpressionCode» )*( «e.right.generateExpressionCode» )'''
	}
	
	def dispatch CharSequence generateExpressionCode( DivExpression e ) {
		'''( «e.left.generateExpressionCode» )/( «e.right.generateExpressionCode» )'''
	}
	
	def dispatch CharSequence generateExpressionCode( SumExpression e ) {
		'''( «e.left.generateExpressionCode» )+( «e.right.generateExpressionCode» )'''
	}
	
	def dispatch CharSequence generateExpressionCode( DiffExpression e ) {
		'''( «e.left.generateExpressionCode» )-( «e.right.generateExpressionCode» )'''
	}
	
	def dispatch CharSequence generateExpressionCode( EqualRelationExpression e ) {
		'''-Math.abs(( «e.left.generateExpressionCode» )-( «e.right.generateExpressionCode» ))'''
	}
	
	def dispatch CharSequence generateExpressionCode( DisEqualRelationExpression e ) {
		'''Math.abs(( «e.left.generateExpressionCode» )-( «e.right.generateExpressionCode» ))'''
	}
	
	def dispatch CharSequence generateExpressionCode( LessRelationExpression e ) {
		'''((«e.right.generateExpressionCode») - («e.left.generateExpressionCode»))'''
	}
	
	def dispatch CharSequence generateExpressionCode( LessOrEqualRelationExpression e ) {
		'''((«e.right.generateExpressionCode») - («e.left.generateExpressionCode»))'''
	}
	
	def dispatch CharSequence generateExpressionCode( GreaterOrEqualRelationExpression e ) {
		'''((«e.left.generateExpressionCode») - («e.right.generateExpressionCode»))'''
	}
	
	def dispatch CharSequence generateExpressionCode( GreaterRelationExpression e ) {
		'''((«e.left.generateExpressionCode») - («e.right.generateExpressionCode»))'''
	}
	
	def dispatch CharSequence generateExpressionCode( Expression e ) {
		'''0'''
	}


	def dispatch CharSequence generateFormulaCode( OrFormula formula ) {
		'''
		new OrFormula( 
			«formula.left.generateFormulaCode» ,
			«formula.right.generateFormulaCode»
		)
		'''
	}

	def dispatch CharSequence generateFormulaCode( AndFormula formula ) {
		'''
		new AndFormula( 
			«formula.left.generateFormulaCode» ,
			«formula.right.generateFormulaCode»
		)
		'''
	}

	def dispatch CharSequence generateFormulaCode( UntilFormula formula ) {
		'''
		new UntilFormula( 
			«formula.interval.generateParametricIntervalCode» ,
			«formula.left.generateFormulaCode» ,
			«formula.right.generateFormulaCode»
		)
		'''
	}

	def dispatch CharSequence generateFormulaCode( GloballyFormula formula ) {
		'''
		new GloballyFormula( 
			«formula.interval.generateParametricIntervalCode» ,
			«formula.arg.generateFormulaCode»
		)		
		'''
	}

	def CharSequence generateParametricIntervalCode( Interval interval ) {
		'''
		new ParametricInterval( 
			new ParametricExpression() {
			
				public SignalExpression eval( final Map<String,Double> parameters ) {

					return new SignalExpression() {
						
						public double eval( double ... variables ) {
							return «interval.min.generateExpressionCode»;
						}
						
					};					
					
				}
				
			} , 
			new ParametricExpression() {
			
				public SignalExpression eval( final Map<String,Double> parameters ) {

					return new SignalExpression() {
						
						public double eval( double ... variables ) {
							return «interval.max.generateExpressionCode»;
						}
						
					};					
					
				}
				
			} 		
		)		
		'''		
	}

	def dispatch CharSequence generateFormulaCode( EventuallyFormula formula ) {
		'''
		new EventuallyFormula( 
			«formula.interval.generateParametricIntervalCode» ,
			«formula.arg.generateFormulaCode»
		)		
		'''
	}

	def dispatch CharSequence generateFormulaCode( SurroundFormula formula ) {
		'''
		new SurroundFormula( 
			«formula.interval.generateParametricIntervalCode» ,
			«formula.left.generateFormulaCode» ,
			«formula.right.generateFormulaCode»
		)		
		'''
	}

	def dispatch CharSequence generateFormulaCode( SomewhereFormula formula ) {
		'''
		new SomewhereFormula( 
			«formula.interval.generateParametricIntervalCode» ,
			«formula.arg.generateFormulaCode»
		)		
		'''
	}

	def dispatch CharSequence generateFormulaCode( EverywhereFormula formula ) {
		'''
		new EverywhereFormula( 
			«formula.interval.generateParametricIntervalCode» ,
			«formula.arg.generateFormulaCode»
		)		
		'''
	}

	def dispatch CharSequence generateFormulaCode( NotFormula formula ) {
		'''
		new NotFormula( 
			«formula.arg.generateFormulaCode»
		)		
		'''
	}

	def dispatch CharSequence generateFormulaCode( ReferencedFormula formula ) {
		'''
		new ReferencedFormula( 
			this ,
			"«formula.reference.name»"
		)		
		'''
	}
	
	def dispatch CharSequence generateFormulaCode( AtomicFormula formula ) {
		'''
		new AtomicFormula( 
			new ParametricExpression( ) {
			
				public SignalExpression eval( Map<String, Double> parameters ) {
					
					return new SignalExpression() {						
								
						public double eval(double... variables) {
							return «formula.value.generateExpressionCode»;
						}	
											
					};	
								
				}
			
			} , 
			«formula.value.strictParameter»
		)		
		'''
	}
	
	def getStrictParameter( RelationExpression r ) {
		switch r {
			LessOrEqualRelationExpression: '''false'''
			LessRelationExpression: '''true'''
			EqualRelationExpression: '''false'''
			DisEqualRelationExpression: '''true'''
			GreaterOrEqualRelationExpression: '''false'''
			GreaterRelationExpression: '''true'''
		}		
	}	
	
}
